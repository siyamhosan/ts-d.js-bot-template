import { exec } from 'node:child_process'
import { readdir, stat } from 'node:fs/promises'
import { readFileSync, writeFileSync } from 'node:fs'
import chalk from 'chalk'
import { parentPort } from 'node:worker_threads'

console.trace = (start: number, text: string, group?: string) => {
  const d = new Date().toLocaleString().toUpperCase().replace(', ', ' ')
  const took = (Date.now() - start) / 1000
  const tookColor = (took: number) => {
    if (took < 5) return chalk.greenBright(took + 's')
    else if (took < 15) return chalk.yellowBright(took + 's')
    else return chalk.redBright(took + 's')
  }

  if (group) {
    console.log(
      `[${d} ${colorize('debug')}] [${group}] ${text} ${tookColor(took)}`
    )
  } else console.log(`[${d} ${colorize('debug')}] ${text} ${tookColor(took)}`)
}

parentPort?.on('message', (of: string) => {
  Compiler(of).then(() => {
    parentPort?.postMessage('done')
  })
})

export async function Compiler (of: string): Promise<void> {
  const startCompiler = Date.now()
  const dirs = await readdir(`./src/main/${of}/`)

  const exportedClasses: string[] = []

  let bundledContent = ''

  let fileCount = 0
  const filesPaths = []

  for (const dir of dirs) {
    if (dir === 'bundle') continue
    const files = (await readdir(`./src/main/${of}/${dir}/`)).filter(f =>
      f.endsWith('.ts')
    )

    for (const file of files) {
      if (!(await stat(`src/main/${of}/${dir}/${file}`)).isFile()) continue
      const eventContent = readFileSync(
        `./src/main/${of}/${dir}/${file}`,
        'utf-8'
      )
      const className = eventContent.match(/export\s+class\s+(\w+)/)
      if (className) {
        exportedClasses.push(className[1])
      }
      bundledContent += eventContent + '\n'
      fileCount++
      filesPaths.push(`./src/main/${of}/${dir}/${file}`)
    }
  }

  const importRegex = /^import\s?([\w]+|\{[\s,\w]+\})\s?from\s?'[\S]+'/gm

  const imports = bundledContent.match(importRegex) || []

  const mergedImports = mergeImports(imports)

  const bundleWithOutImport = bundledContent.replace(importRegex, '')

  const formattedCode = `${mergedImports.join('\n')}\n\n${bundleWithOutImport}`

  // src\main\events\bundle\events-bundled.ts
  writeFileSync(
    `./src/main/${of}/bundle/${of}-bundled.ts`,
    `// This file is auto-generated by the eventManager.ts file.
// Do not edit this file manually.
${formattedCode}
`
  )

  await exec(`eslint --fix ./src/main/${of}/bundle/${of}-bundled.ts`)

  console.trace(
    startCompiler,
    chalk.bold('Compiler finished in :'),
    chalk.bold(of.slice(0, -3))
  )

  writeFileSync(
    `./src/main/${of}/bundle/${of}-compiled.json`,
    JSON.stringify({
      exportedClasses,
      compiledFiles: fileCount,
      imports,
      filesPaths,
      lastUpdated: Date.now()
    })
  )
}

function mergeImports (imports: string[]): string[] {
  const importsData: {
    importNames: string[]
    importPath: string
    isDefault: boolean
  }[] = []

  const importRegex = /^import\s?(\{?[\w\s,]+\}?)\s?from\s?('[\S]+')/

  for (const importStatement of imports) {
    const matches = importRegex.exec(importStatement)
    if (!matches) continue
    const [, importName, importPath] = matches

    if (importName.includes('{')) {
      // Multiple imports
      const importNames = importName
        .replace('{', '')
        .replace('}', '')
        .split(',')
        .map(i => i.trim())

      importsData.push({
        importNames,
        importPath,
        isDefault: false
      })
    } else {
      // Single import
      importsData.push({
        importNames: [importName],
        importPath,
        isDefault: true
      })
    }
  }

  // Merge imports
  const fileredImportsData: {
    importNames: string[]
    importPath: string
    isDefault: boolean
  }[] = []

  for (const { importNames, importPath, isDefault } of importsData) {
    const existingImport = fileredImportsData.find(
      i => i.importPath === importPath
    )

    if (existingImport) {
      for (const importName of importNames) {
        if (!existingImport.importNames.includes(importName)) {
          existingImport.importNames.push(importName)
        }
      }
    } else {
      fileredImportsData.push({
        importNames,
        importPath,
        isDefault
      })
    }
  }

  const mergedImports = []

  for (const { importNames, importPath, isDefault } of fileredImportsData) {
    if (!isDefault) {
      mergedImports.push(`import {${importNames.join(',')}} from ${importPath}`)
    } else {
      mergedImports.push(`import ${importNames[0]} from ${importPath}`)
    }
  }

  return mergedImports
}

type LogType = 'info' | 'warn' | 'error' | 'debug'
const colorize = (level: LogType): string => {
  const obj = {
    info: chalk.green('INFO'),
    warn: chalk.yellow('WARN'),
    error: chalk.red('ERROR'),
    debug: chalk.whiteBright('DEBUG')
  }

  return obj[level]
}
